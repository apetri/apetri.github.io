<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; LensTools 0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="LensTools 0.2 documentation" href="index.html" />
    <link rel="prev" title="Welcome to LensTools’s documentation!" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to LensTools’s documentation!"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">LensTools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is still in pre-alpha stage, not tested yet on full scale! Use at your own risk!</p>
</div>
<span class="target" id="module-lenstools"></span><p>A collection of tools widely used in Weak Gravitational Lensing data analyses</p>
<div class="section" id="convergence-maps">
<h2>Convergence maps<a class="headerlink" href="#convergence-maps" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lenstools.ConvergenceMap">
<em class="property">class </em><tt class="descclassname">lenstools.</tt><tt class="descname">ConvergenceMap</tt><big>(</big><em>kappa</em>, <em>angle</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that handles 2D convergence maps and allows to compute their topological descriptors (power spectrum, peak counts, minkowski functionals)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools</span> <span class="kn">import</span> <span class="n">ConvergenceMap</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools.defaults</span> <span class="kn">import</span> <span class="n">load_fits_default_convergence</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">load_fits_default_convergence</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imshow</span><span class="p">(</span><span class="n">test_map</span><span class="o">.</span><span class="n">kappa</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="lenstools.ConvergenceMap.cross">
<tt class="descname">cross</tt><big>(</big><em>other</em>, <em>l_edges</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures the cross power spectrum between two convergence maps at the multipole moments specified in the input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> (<em>ConvergenceMap instance</em>) &#8211; The other convergence map</li>
<li><strong>l_edges</strong> (<em>array</em>) &#8211; Multipole bin edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple &#8211; (l &#8211; array,Pl &#8211; array) = (multipole moments, cross power spectrum at multipole moments)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AssertionError if l_edges are not provided or the other map has not the same shape as the input one</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">load_fits_default_convergence</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map2.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">load_fits_default_convergence</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">l_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">200.0</span><span class="p">,</span><span class="mf">5000.0</span><span class="p">,</span><span class="mf">200.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span><span class="n">Pl</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">other_map</span><span class="p">,</span><span class="n">l_edges</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="lenstools.ConvergenceMap.fromfilename">
<em class="property">classmethod </em><tt class="descname">fromfilename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.fromfilename" title="Permalink to this definition">¶</a></dt>
<dd><p>This class method allows to read the map from a data file; the details of the loading are performed by the loader function. The only restriction to this function is that it must return a tuple (angle,kappa)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; The positional arguments that are to be passed to the loader (typically the file name)</li>
<li><strong>kwargs</strong> &#8211; Only one keyword is accepted &#8220;loader&#8221; is a pointer to the previously defined loader method (a template is defaults.load_fits_default_convergence)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.gradient">
<tt class="descname">gradient</tt><big>(</big><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gradient of the map and sets the gradient_x,gradient_y attributes accordingly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple &#8211; (gradient_x,gradient_y)</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gx</span><span class="p">,</span><span class="n">gy</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">gradient</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.hessian">
<tt class="descname">hessian</tt><big>(</big><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the hessian of the map and sets the hessian_xx,hessian_yy,hessian_xy attributes accordingly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple &#8211; (hessian_xx,hessian_yy,hessian_xy)</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hxx</span><span class="p">,</span><span class="n">hyy</span><span class="p">,</span><span class="n">hxy</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">hessian</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.minkowskiFunctionals">
<tt class="descname">minkowskiFunctionals</tt><big>(</big><em>thresholds</em>, <em>norm=False</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.minkowskiFunctionals" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures the three Minkowski functionals (area,perimeter and genus characteristic) of the specified map excursion sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thresholds</strong> (<em>array</em>) &#8211; thresholds that define the excursion sets to consider</li>
<li><strong>norm</strong> (<em>bool.</em>) &#8211; normalization; if set to a True, interprets the thresholds array as units of sigma (the map standard deviation)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple &#8211; (nu &#8211; array, V0 &#8211; array, V1 &#8211; array, V2 &#8211; array) nu are the bins midpoints and V are the Minkowski functionals</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AssertionError if thresholds array is not provided</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span><span class="p">,</span><span class="n">V0</span><span class="p">,</span><span class="n">V1</span><span class="p">,</span><span class="n">V2</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">minkowskiFunctionals</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.moments">
<tt class="descname">moments</tt><big>(</big><em>connected=False</em>, <em>dimensionless=False</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures the first nine moments of the convergence map (two quadratic, three cubic and four quartic)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>connected</strong> (<em>bool.</em>) &#8211; if set to True returns only the connected part of the moments</li>
<li><strong>dimensionless</strong> (<em>bool.</em>) &#8211; if set to True returns the dimensionless moments, normalized by the appropriate powers of the variance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array &#8211; (sigma0,sigma1,S0,S1,S2,K0,K1,K2,K3)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var0</span><span class="p">,</span><span class="n">var1</span><span class="p">,</span><span class="n">sk0</span><span class="p">,</span><span class="n">sk1</span><span class="p">,</span><span class="n">sk2</span><span class="p">,</span><span class="n">kur0</span><span class="p">,</span><span class="n">kur1</span><span class="p">,</span><span class="n">kur2</span><span class="p">,</span><span class="n">kur3</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">moments</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sk0</span><span class="p">,</span><span class="n">sk1</span><span class="p">,</span><span class="n">sk2</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">dimensionless</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kur0</span><span class="p">,</span><span class="n">kur1</span><span class="p">,</span><span class="n">kur2</span><span class="p">,</span><span class="n">kur3</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">connected</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">dimensionless</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">5</span><span class="p">:]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.peakCount">
<tt class="descname">peakCount</tt><big>(</big><em>thresholds</em>, <em>norm=False</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.peakCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the peaks in the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thresholds</strong> (<em>array</em>) &#8211; thresholds extremes that define the binning of the peak histogram</li>
<li><strong>norm</strong> (<em>bool.</em>) &#8211; normalization; if set to a True, interprets the thresholds array as units of sigma (the map standard deviation)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple &#8211; (threshold midpoints &#8211; array, differential peak counts at the midpoints &#8211; array)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AssertionError if thresholds array is not provided</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">map</span><span class="o">.</span><span class="n">kappa</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="nb">map</span><span class="o">.</span><span class="n">kappa</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span><span class="p">,</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">peakCount</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.powerSpectrum">
<tt class="descname">powerSpectrum</tt><big>(</big><em>l_edges</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.powerSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures the power spectrum of the convergence map at the multipole moments specified in the input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>l_edges</strong> (<em>array</em>) &#8211; Multipole bin edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple &#8211; (l &#8211; array,Pl &#8211; array) = (multipole moments, power spectrum at multipole moments)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AssertionError if l_edges are not provided</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ConvergenceMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;map.fit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">200.0</span><span class="p">,</span><span class="mf">5000.0</span><span class="p">,</span><span class="mf">200.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span><span class="n">Pl</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">powerSpectrum</span><span class="p">(</span><span class="n">l_edges</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ConvergenceMap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>angle_in_arcmin</em>, <em>kind='gaussian'</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#lenstools.ConvergenceMap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a smoothing operation on the convergence map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>angle_in_arcmin</strong> (<em>float.</em>) &#8211; size of the smoothing kernel in arcminutes</li>
<li><strong>kind</strong> (<em>str.</em>) &#8211; type of smoothing to be performed (only implemented gaussian so far)</li>
<li><strong>inplace</strong> (<em>bool.</em>) &#8211; if set to True performs the smoothing in place overwriting the old convergence map</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ConvergenceMap instance (or None if inplace is True)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shear-maps">
<h2>Shear maps<a class="headerlink" href="#shear-maps" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lenstools.ShearMap">
<em class="property">class </em><tt class="descclassname">lenstools.</tt><tt class="descname">ShearMap</tt><big>(</big><em>gamma</em>, <em>angle</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that handles 2D shear maps and allows to perform a set of operations on them</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools</span> <span class="kn">import</span> <span class="n">ShearMap</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">ShearMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;shear.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">lenstools</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">load_fits_default_shear</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="o">.</span><span class="n">side_angle</span>
<span class="go">1.95</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="o">.</span><span class="n">gamma</span>
<span class="go">#The actual map values</span>
</pre></div>
</div>
<dl class="method">
<dt id="lenstools.ShearMap.convergence">
<tt class="descname">convergence</tt><big>(</big><big>)</big><a class="headerlink" href="#lenstools.ShearMap.convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs the convergence from the E component of the shear</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">new ConvergenceMap instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.ShearMap.decompose">
<tt class="descname">decompose</tt><big>(</big><em>l_edges</em>, <em>keep_fourier=False</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes the shear map into its E and B modes components and returns the respective power spectral densities at the specified multipole moments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>l_edges</strong> (<em>array</em>) &#8211; Multipole bin edges</li>
<li><strong>keep_fourier</strong> (<em>bool.</em>) &#8211; If set to True, holds the Fourier transforms of the E and B mode maps into the E and B attributes of the ShearMap instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">returns:</th><td class="field-body">tuple &#8211; (l &#8211; array,P_EE,P_BB,P_EB &#8211; arrays) = (multipole moments, EE,BB power spectra and EB cross power)</td>
</tr>
</tbody>
</table>
</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_map</span> <span class="o">=</span> <span class="n">ShearMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;shear.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">load_fits_default_shear</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">300.0</span><span class="p">,</span><span class="mf">5000.0</span><span class="p">,</span><span class="mf">200.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span><span class="n">EE</span><span class="p">,</span><span class="n">BB</span><span class="p">,</span><span class="n">EB</span> <span class="o">=</span> <span class="n">test_map</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">l_edges</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="lenstools.ShearMap.fromEBmodes">
<em class="property">classmethod </em><tt class="descname">fromEBmodes</tt><big>(</big><em>fourier_E</em>, <em>fourier_B</em>, <em>angle=3.14</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap.fromEBmodes" title="Permalink to this definition">¶</a></dt>
<dd><p>This class method allows to build a shear map specifying its E and B mode components</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fourier_E</strong> (<em>numpy 2D array, must be of type np.complex128 and must have a shape that is appropriate for a real fourier transform, i.e. (N,N/2 + 1); N should be a power of 2</em>) &#8211; E mode of the shear map in fourier space</li>
<li><strong>fourier_B</strong> (<em>numpy 2D array, must be of type np.complex128 and must have a shape that is appropriate for a real fourier transform, i.e. (N,N/2 + 1); N should be a power of 2</em>) &#8211; B mode of the shear map in fourier space</li>
<li><strong>angle</strong> (<em>float.</em>) &#8211; Side angle of the real space map in degrees</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the corresponding ShearMap instance</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AssertionErrors for inappropriate inputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lenstools.ShearMap.fromfilename">
<em class="property">classmethod </em><tt class="descname">fromfilename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap.fromfilename" title="Permalink to this definition">¶</a></dt>
<dd><p>This class method allows to read the map from a data file; the details of the loading are performed by the loader function. The only restriction to this function is that it must return a tuple (angle,gamma)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; The positional arguments that are to be passed to the loader (typically the file name)</li>
<li><strong>kwargs</strong> &#8211; Only one keyword is accepted &#8220;loader&#8221; is a pointer to the previously defined loader method (a template is defaults.load_fits_default_shear above)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.ShearMap.sticks">
<tt class="descname">sticks</tt><big>(</big><em>ax</em>, <em>pixel_step=10</em>, <em>multiplier=1.0</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap.sticks" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the ellipticity map using the shear components</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ax</strong> (<em>matplotlib ax object</em>) &#8211; ax on which to draw the ellipticity field</li>
<li><strong>pixel_step</strong> (<em>int.</em>) &#8211; One arrow will be drawn every pixel_step pixels to avoid arrow overplotting</li>
<li><strong>multiplier</strong> (<em>float.</em>) &#8211; Multiplies the stick length by a factor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ax &#8211; the matplotlib ax object on which the stick field was drawn</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">ShearMap</span><span class="o">.</span><span class="n">fromfilename</span><span class="p">(</span><span class="s">&quot;shear.fit&quot;</span><span class="p">,</span><span class="n">loader</span><span class="o">=</span><span class="n">load_fits_default_shear</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="o">.</span><span class="n">sticks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">pixel_step</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.ShearMap.visualizeComponents">
<tt class="descname">visualizeComponents</tt><big>(</big><em>axes</em>, <em>components='EE</em>, <em>BB</em>, <em>EB'</em>, <em>region=(200</em>, <em>9000</em>, <em>-9000</em>, <em>9000)</em><big>)</big><a class="headerlink" href="#lenstools.ShearMap.visualizeComponents" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the full 2D E and B mode power spectrum (useful to test statistical isotropicity)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axes</strong> (<em>matplotlib ax object or array of ax objects, can be None in which case new axes are created</em>) &#8211; axes on which to draw the ellipticity field</li>
<li><strong>components</strong> &#8211; string that contains the components to plot; the format is a sequence of {EE,BB,EB} separated by commas</li>
<li><strong>region</strong> (<em>tuple (lx_min,lx_max,ly_min,ly_max)</em>) &#8211; selects the multipole region to visualize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">axes &#8211; array of matplotlib axes objects on which the plots were drawn</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="statistics">
<h2>Statistics<a class="headerlink" href="#statistics" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lenstools.Ensemble">
<em class="property">class </em><tt class="descclassname">lenstools.</tt><tt class="descname">Ensemble</tt><big>(</big><em>file_list=None</em>, <em>data=None</em>, <em>num_realizations=0</em>, <em>metric='chi2'</em><big>)</big><a class="headerlink" href="#lenstools.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that handles statistical operations on weak lensing maps; an ensemble is a collection of different statistical realization of the same random variable. This class has an attribute &#8216;data&#8217; that is a numpy array which first axis corresponds to the realization number.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools.statistics</span> <span class="kn">import</span> <span class="n">Ensemble</span>
</pre></div>
</div>
<dl class="method">
<dt id="lenstools.Ensemble.compare">
<tt class="descname">compare</tt><big>(</big><em>rhs</em><big>)</big><a class="headerlink" href="#lenstools.Ensemble.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>A comparison operation between ensembles: computes a chi2-style difference between two different ensembles to assert how different they are</p>
</dd></dl>

<dl class="method">
<dt id="lenstools.Ensemble.covariance">
<tt class="descname">covariance</tt><big>(</big><big>)</big><a class="headerlink" href="#lenstools.Ensemble.covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ensemble covariance matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ndarray with the covariance matrix, has shape (self.data[0],self.data[0])</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lenstools.Ensemble.fromfilelist">
<em class="property">classmethod </em><tt class="descname">fromfilelist</tt><big>(</big><em>file_list</em><big>)</big><a class="headerlink" href="#lenstools.Ensemble.fromfilelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the ensemble from a file list: each file corresponds to a different realization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_list</strong> (<em>list of str.</em>) &#8211; List of files on which to define the ensemble</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.Ensemble.load">
<tt class="descname">load</tt><big>(</big><em>callback_loader</em>, <em>pool=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lenstools.Ensemble.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the ensemble into memory, can spread the calculations on multiple processors using a MPI pool</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>callback_loader</strong> (<em>function, must take in a file name (str.) and return a numpy array with the loaded data</em>) &#8211; This function gets executed on each of the files in the list and populates the ensemble; must take in a dictionary as its only parameter and must return a numpy array</li>
<li><strong>pool</strong> (<em>MPI pool object</em>) &#8211; MPI pool for multiprocessing (imported from emcee <a class="reference external" href="https://github.com/dfm/emcee">https://github.com/dfm/emcee</a>)</li>
<li><strong>kwargs</strong> (<em>Keyword arguments</em>) &#8211; Any additional keyword arguments to be passed to callback_loader</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools</span> <span class="kn">import</span> <span class="n">Ensemble</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lenstools.statistics</span> <span class="kn">import</span> <span class="n">default_callback_loader</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">map_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;conv1.fit&quot;</span><span class="p">,</span><span class="s">&quot;conv2.fit&quot;</span><span class="p">,</span><span class="s">&quot;conv3.fit&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">200.0</span><span class="p">,</span><span class="mf">50000.0</span><span class="p">,</span><span class="mf">200.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_ensemble</span> <span class="o">=</span> <span class="n">Ensemble</span><span class="o">.</span><span class="n">fromfilelist</span><span class="p">(</span><span class="n">map_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv_ensemble</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">callback_loader</span><span class="o">=</span><span class="n">default_callback_loader</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span><span class="n">l_edges</span><span class="o">=</span><span class="n">l_edges</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lenstools.Ensemble.mean">
<tt class="descname">mean</tt><big>(</big><big>)</big><a class="headerlink" href="#lenstools.Ensemble.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ensemble average over realizations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ndarray with the averages, has the same shape as self.data[0]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.Ensemble.split">
<tt class="descname">split</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#lenstools.Ensemble.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the * operator: this method uses an Indexer instance to break down a multiple descriptor ensemble in many, smaller, single descriptor ensembles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>Indexer instance</em>) &#8211; index of descriptors with which to perform the split</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of Ensemble instances, one for each element in index</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AssertionError if shape of the ensemble data is not suitable</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="noise">
<h2>Noise<a class="headerlink" href="#noise" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lenstools.GaussianNoiseGenerator">
<em class="property">class </em><tt class="descclassname">lenstools.</tt><tt class="descname">GaussianNoiseGenerator</tt><big>(</big><em>shape</em>, <em>side_angle</em>, <em>label</em><big>)</big><a class="headerlink" href="#lenstools.GaussianNoiseGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that handles generation of Gaussian simulated noise maps</p>
<dl class="classmethod">
<dt id="lenstools.GaussianNoiseGenerator.forMap">
<em class="property">classmethod </em><tt class="descname">forMap</tt><big>(</big><em>conv_map</em><big>)</big><a class="headerlink" href="#lenstools.GaussianNoiseGenerator.forMap" title="Permalink to this definition">¶</a></dt>
<dd><p>This class method generates a Gaussian noise generator intended to be used on a convergence map: i.e. the outputs of its methods can be added to the convergence map in question to simulate the presence of noise</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conv_map</strong> (<em>ConvergenceMap instance</em>) &#8211; The blueprint of the convergence map you want to generate the noise for</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">AssertionError if conv_map is not a ConvergenceMap instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.GaussianNoiseGenerator.fromConvPower">
<tt class="descname">fromConvPower</tt><big>(</big><em>power_func</em>, <em>seed=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lenstools.GaussianNoiseGenerator.fromConvPower" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses a supplied power spectrum to generate correlated noise maps in real space via FFTs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>power_func</strong> (<em>function with the above specifications, or numpy array (l,Pl) of shape (2,n)</em>) &#8211; function that given a numpy array of l&#8217;s returns a numpy array with the according Pl&#8217;s (this is the input power spectrum); alternatively you can pass an array (l,Pl) and the power spectrum will be calculated with scipy&#8217;s interpolation routines</li>
<li><strong>seed</strong> (<em>int.</em>) &#8211; seed of the random generator</li>
<li><strong>kwargs</strong> &#8211; keyword arguments to be passed to power_func, or to the interpolate.interp1d routine</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ConvergenceMap instance of the same exact shape as the one used as blueprint</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.GaussianNoiseGenerator.getShapeNoise">
<tt class="descname">getShapeNoise</tt><big>(</big><em>z=1.0</em>, <em>ngal=15.0</em>, <em>seed=0</em><big>)</big><a class="headerlink" href="#lenstools.GaussianNoiseGenerator.getShapeNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>This method generates a white, gaussian shape noise map for the given redshift of the map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>float.</em>) &#8211; single redshift of the backround sources on the map</li>
<li><strong>ngal</strong> (<em>float.</em>) &#8211; assumed number of galaxies per square arcminute</li>
<li><strong>seed</strong> (<em>int.</em>) &#8211; seed of the random generator</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ConvergenceMap instance of the same exact shape as the one used as blueprint</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lenstools.index">
<span id="indexing"></span><h2>Indexing<a class="headerlink" href="#module-lenstools.index" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-index"></span><dl class="class">
<dt id="lenstools.index.Indexer">
<em class="property">class </em><tt class="descclassname">lenstools.index.</tt><tt class="descname">Indexer</tt><big>(</big><em>descriptor_list</em><big>)</big><a class="reference internal" href="_modules/lenstools/index.html#Indexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.index.Indexer" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is useful for indexing an array of statistical descriptors that are hstacked together; the Indexer instance keeps track of the memory regions where the different descriptors are stored</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>descriptor_list</strong> (<em>list.</em>) &#8211; list of Descriptor subinstances, such as PowerSpectrum; each of these sub instances must be a subclass of Descriptor with a &#8216;first&#8217; and &#8216;last&#8217; getter methods implemented</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lenstools.index.PowerSpectrum">
<em class="property">class </em><tt class="descclassname">lenstools.index.</tt><tt class="descname">PowerSpectrum</tt><big>(</big><em>l_edges</em><big>)</big><a class="reference internal" href="_modules/lenstools/index.html#PowerSpectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.index.PowerSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Power spectrum indexing class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>l_edges</strong> (<em>array</em>) &#8211; bin edges of multipole moments</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lenstools.index.Peaks">
<em class="property">class </em><tt class="descclassname">lenstools.index.</tt><tt class="descname">Peaks</tt><big>(</big><em>thresholds</em><big>)</big><a class="reference internal" href="_modules/lenstools/index.html#Peaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.index.Peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Peaks histogram indexing class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>thresholds</strong> (<em>array</em>) &#8211; peak histogram bin edges</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lenstools.index.MinkowskiAll">
<em class="property">class </em><tt class="descclassname">lenstools.index.</tt><tt class="descname">MinkowskiAll</tt><big>(</big><em>thresholds</em><big>)</big><a class="reference internal" href="_modules/lenstools/index.html#MinkowskiAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.index.MinkowskiAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Minkowski functionals indexing class, inherits from Peaks; the add-ons are some methods that deal with the fact that there are 3 Minkowski functionals</p>
</dd></dl>

<dl class="class">
<dt id="lenstools.index.MinkowskiSingle">
<em class="property">class </em><tt class="descclassname">lenstools.index.</tt><tt class="descname">MinkowskiSingle</tt><big>(</big><em>thresholds</em><big>)</big><a class="reference internal" href="_modules/lenstools/index.html#MinkowskiSingle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.index.MinkowskiSingle" title="Permalink to this definition">¶</a></dt>
<dd><p>Single Minkowski functional indexing class, identical to Peaks</p>
</dd></dl>

</div>
<div class="section" id="module-lenstools.defaults">
<span id="defaults"></span><h2>Defaults<a class="headerlink" href="#module-lenstools.defaults" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lenstools.defaults.load_fits_default_convergence">
<tt class="descclassname">lenstools.defaults.</tt><tt class="descname">load_fits_default_convergence</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/lenstools/defaults.html#load_fits_default_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.defaults.load_fits_default_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the default convergence fits file loader, it assumes that the two components of the shear are stored in two different image FITS files, which have an ANGLE keyword in the header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gamma_file</strong> &#8211; Name of the FITS file that contains the shear map</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple &#8211; (angle,ndarray &#8211; kappa; kappa is the convergence map)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">IOError if the FITS files cannot be opened or do not exist</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lenstools.defaults.load_fits_default_shear">
<tt class="descclassname">lenstools.defaults.</tt><tt class="descname">load_fits_default_shear</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/lenstools/defaults.html#load_fits_default_shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.defaults.load_fits_default_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the default shear fits file loader, it assumes that the two components of the shear are stored in a single image FITS file, which have an ANGLE keyword in the header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gamma_file</strong> &#8211; Name of the FITS file that contains the shear map</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple &#8211; (angle,ndarray &#8211; gamma; gamma[0] is the gamma1 map, gamma[1] is the gamma2 map); the maps must follow matrix ordering, i.e. the first axis (0) is y and the second axis (1) is x. This matters for the E/B mode decomposition</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">IOError if the FITS files cannot be opened or do not exist</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lenstools.defaults.default_callback_loader">
<tt class="descclassname">lenstools.defaults.</tt><tt class="descname">default_callback_loader</tt><big>(</big><em>args</em><big>)</big><a class="reference internal" href="_modules/lenstools/defaults.html#default_callback_loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.defaults.default_callback_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Default ensemble loader: reads a FITS data file containing a convergence map and measures its power spectrum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>Dictionary</em>) &#8211; A dictionary that contains all the relevant parameters as keys. Must have a &#8220;file_name&#8221; key</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">ndarray of the measured statistics</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AssertionError if the input dictionary doesn&#8217;t have the required keywords</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lenstools.defaults.convergence_measure_all">
<tt class="descclassname">lenstools.defaults.</tt><tt class="descname">convergence_measure_all</tt><big>(</big><em>args</em><big>)</big><a class="reference internal" href="_modules/lenstools/defaults.html#convergence_measure_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.defaults.convergence_measure_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures all the statistical descriptors of a convergence map as indicated by the Indexer instance args[&#8216;index&#8217;]</p>
</dd></dl>

</div>
<div class="section" id="module-lenstools.limber">
<span id="limber-integration"></span><h2>Limber integration<a class="headerlink" href="#module-lenstools.limber" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-limber"></span><dl class="class">
<dt id="lenstools.limber.LimberIntegrator">
<em class="property">class </em><tt class="descclassname">lenstools.limber.</tt><tt class="descname">LimberIntegrator</tt><big>(</big><em>lValues</em>, <em>cosmoModel=FlatLambdaCDM(name=&quot;WMAP9&quot;</em>, <em>H0=69.3 km / (Mpc s)</em>, <em>Om0=0.286</em>, <em>Tcmb0=2.725 K</em>, <em>Neff=3.04</em>, <em>m_nu=[ 0.  0.  0.] eV)</em><big>)</big><a class="reference internal" href="_modules/lenstools/limber.html#LimberIntegrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.limber.LimberIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p>A 3D power spectrum integrator that will compute the convergence power spectrum  using the Limber approximation. The units for quantities with dimensions of length are assumed to be Mpc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lValues</strong> (<em>array</em>) &#8211; Desired multipole values for the convergence power spectrum</li>
<li><strong>cosmoModel</strong> (<em>astropy.cosmology</em>) &#8211; One of astropy.cosmology objects (WMAP9 cosmology is set by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lenstools.limber.LimberIntegrator.computeConvergence">
<tt class="descname">computeConvergence</tt><big>(</big><em>z</em>, <em>matterPower=None</em>, <em>powFileRoot=None</em>, <em>extension='.dat'</em><big>)</big><a class="reference internal" href="_modules/lenstools/limber.html#LimberIntegrator.computeConvergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.limber.LimberIntegrator.computeConvergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the convergence power spectrum with the Limber integral of the 3D matter power spectrum;
this still assumes a single source redshift at z0 = max(z)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>array</em>) &#8211; redshift bins at which the matter power spectrum is calculated; the z array must be sorted in ascending order
and z[0] must be &gt;0 even if small, otherwise this throws an exception</li>
<li><strong>matterPower</strong> (<em>ndarray</em>) &#8211; values of the matter power spectrum at corresponding z (first column must be k, the rest P(k,z), one for each z)</li>
<li><strong>powFileRoot</strong> (<em>str.</em>) &#8211; common root name of files in which the 3d power spectrum is stored; if None it is assumed that all the
information is already loaded in the matterPower array. Throws and exception if both are None</li>
<li><strong>extension</strong> (<em>str.</em>) &#8211; extension of text files with 3d power spectrum, default is .dat</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array &#8211; the convergence power spectrum at the l Values specified in the constructor</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ValueError</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lenstools.limber.LimberIntegrator.writeCAMBSettings">
<tt class="descname">writeCAMBSettings</tt><big>(</big><em>z</em>, <em>powFileRoot='matterpower'</em>, <em>transfer_high_precision=False</em>, <em>transfer_k_per_logint=0</em>, <em>transfer_interp_matterpower=True</em><big>)</big><a class="reference internal" href="_modules/lenstools/limber.html#LimberIntegrator.writeCAMBSettings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lenstools.limber.LimberIntegrator.writeCAMBSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a StringIO object that will contain the redshift settings of the CAMB parameter file that will needed
in order for CAMB to produce the linear or non linear matter power spectra that will then be integrated by 
the computeConvergence() method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z</strong> (<em>array</em>) &#8211; redshift bins at which the matter power spectrum is calculated (assumed to be a monotonic array with more than 1 element)</li>
<li><strong>powFileRoot</strong> (<em>str.</em>) &#8211; root of the filename that you want to give to the CAMB power spectrum outputs</li>
<li><strong>transfer_high_precision</strong> (<em>bool.</em>) &#8211; read CAMB documentation (this sets the precision of the calculated transfer function)</li>
<li><strong>transfer_k_per_logint</strong> (<em>int.</em>) &#8211; read CAMB documentation (this sets the k wavenumber binning)</li>
<li><strong>transfer_interp_matterpower</strong> (<em>bool.</em>) &#8211; read CAMB documentation (this sets how the matter power is interpolated between different k&#8217;s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">str &#8211; the portion of the CAMB parameter file relevant to the 3D matter power spectrum</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#convergence-maps">Convergence maps</a></li>
<li><a class="reference internal" href="#shear-maps">Shear maps</a></li>
<li><a class="reference internal" href="#statistics">Statistics</a></li>
<li><a class="reference internal" href="#noise">Noise</a></li>
<li><a class="reference internal" href="#module-lenstools.index">Indexing</a></li>
<li><a class="reference internal" href="#module-lenstools.defaults">Defaults</a></li>
<li><a class="reference internal" href="#module-lenstools.limber">Limber integration</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to LensTools&#8217;s documentation!</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/code.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to LensTools’s documentation!"
             >previous</a> |</li>
        <li><a href="index.html">LensTools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Andrea Petri.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>